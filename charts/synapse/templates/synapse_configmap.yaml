# Copyright 2024 New Vector Ltd
#
# SPDX-License-Identifier: AGPL-3.0-only OR LicenseRef-Element-Commercial
apiVersion: v1
kind: ConfigMap
metadata:
  labels:
    {{- include "element-io.synapse.labels" $ | nindent 4 }}
  name: {{ .Release.Name }}-synapse
  namespace: {{ .Release.Namespace }}
data:
  01-homeserver-underrides.yaml: |
    {{- include "element-io.synapse.config.shared-underrides" . | nindent 4  }}
{{- /*02 files are user provided in Helm values and end up in the Secret*/}}
{{- /*03 files are user provided as secrets rather than directly in Helm*/}}
  04-homeserver-overrides.yaml: |
    {{- include "element-io.synapse.config.shared-overrides" . | nindent 4 }}
  05-main.yaml: |
    {{- include "element-io.synapse.config.processSpecific" (dict "processType" "main" "Values" .Values) | nindent 4 }}
{{- range $workerType, $workerDetails := .Values.workers }}
  05-{{ $workerType }}.yaml: |
    {{- include "element-io.synapse.config.processSpecific" (dict "processType" $workerType "Values" $.Values) | nindent 4 }}
{{- end }}
  log_config.yaml: |
    # Copyright 2024 New Vector Ltd
    #
    # SPDX-License-Identifier: AGPL-3.0-only OR LicenseRef-Element-Commercial
    version: 1

    formatters:
      precise:
        format: '%(asctime)s - %(name)s - %(lineno)d - %(levelname)s - %(request)s - %(message)s'

    handlers:
      console:
        class: logging.StreamHandler
        formatter: precise

    loggers:
    {{- /*
    Increasing synapse.storage.SQL past INFO will log access tokens. Putting in the values default will mean it gets
    nuked if an override is set and then if the root level is increased to debug, the access tokens will be logged.
    Putting here means it is an explicit customer choice to override it.
    */}}
    {{- range $logger, $level := merge dict .Values.logging.levelOverrides (dict "synapse.storage.SQL" "INFO") }}
      {{ $logger }}:
        level: "{{ $level }}"
    {{- end }}

    root:
      level: "{{ .Values.logging.rootLevel }}"
      handlers:
      - console

    disable_existing_loggers: false
  render_config_with_secrets.py: |
    #!/usr/bin/env python3

    from pathlib import Path
    import json
    import os
    import re
    import sys
    import yaml


    def deep_merge_dicts(source, destination):
      for key, value in source.items():
        if isinstance(value, dict):
          deep_merge_dicts(value, destination.setdefault(key, {}))
        else:
          destination[key] = value

    if __name__ == "__main__":
      if len(sys.argv) < 2:
        print(f"Usage {sys.argv[0]} <source files>")
        sys.exit(1)

      source_filenames = sys.argv[1:]
      output = {}

      for source_filename in [Path(source_filename) for source_filename in source_filenames]:
        if not source_filename.exists():
          print(f"{source_filename} doesn't exist. Exitting")
          sys.exit(1)

        if not source_filename.is_file():
          continue

        source_fragment = source_filename.read_text(encoding="utf-8")

        env_var_names = re.findall(r"\$\{([^\}]+)\}", source_fragment)
        for env_var in env_var_names:
          if env_var not in os.environ:
            print(f"{env_var} is not present in the environment. Exitting")
            sys.exit(1)

          replacement_value = json.dumps(os.environ[env_var], ensure_ascii=False)
          source_fragment = source_fragment.replace(f"${{ `{{{` }}env_var{{ `}}}` }}", replacement_value)

        deep_merge_dicts(yaml.safe_load(source_fragment), output)

      print(yaml.dump(output, allow_unicode=True))
